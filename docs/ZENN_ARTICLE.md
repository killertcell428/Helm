# 組織を賢くするAI - Helmの設計思想と実装

## はじめに

Helmは、**組織構造そのものを学習・改善するAI**です。既存のAIエージェントがタスクや成果物を最適化するのに対し、Helmは**組織構造そのものの壊れ方**を見て、改善します。

本記事では、Helmの設計思想と技術的実装について解説します。

## Helmとは何か

### コンセプト

Helmの核心は、**「AIや人ではなく組織を賢くする」**というコンセプトです。

- **既存ツール**: タスクや成果物を最適化（Asana、Jira、CrewAI、AutoGenなど）
- **Helm**: 組織構造（判断構造・責任境界・役割分担）を観測・評価・再設計

### 解決する課題

Helmが解決する3つの構造的課題：

#### 1. 責任所在の不可視化

大企業では、研究で「この仮説は棄却すべきか」、ビジネスで「この事業は撤退すべきか」という痛みを伴う判断の責任者が曖昧になります。

**現状:**
- 意思決定リードタイム: 7-14日
- Zombie Project検知率: 0%

#### 2. 構造固定化バイアス

初期仮説への固執が組織的なバイアスとなり、実験データや市場反応が乏しくなっても、構造的な軌道修正が起きません。

**現状:**
- 代替案検討率: 10%未満

#### 3. ヒト主語の認知限界

実験ログ・会議ログ・KPI変更履歴など、膨大なシグナルを人が手作業で監視する必要があります。

**現状:**
- 経営層レビュー負荷: 15h/週
- 微細な予兆検知率: 0%

## アーキテクチャ設計

### システム全体図

```
┌─────────────────────────────────────────────────────────────┐
│                        フロントエンド                         │
│                    (Next.js + TypeScript)                    │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Case1      │  │   Case2      │  │   Case3      │      │
│  │   デモページ   │  │   デモページ   │  │   デモページ   │      │
│  └──────┬───────┘  └──────────────┘  └──────────────┘      │
│         │                                                      │
│  ┌──────▼───────┐                                            │
│  │  API Client  │  (lib/api.ts)                              │
│  └──────┬───────┘                                            │
└─────────┼─────────────────────────────────────────────────────┘
          │ HTTP REST API / WebSocket
          │
┌─────────▼─────────────────────────────────────────────────────┐
│                      バックエンドAPI                            │
│                    (Python FastAPI)                            │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              APIエンドポイント層                        │   │
│  │  /api/meetings/ingest, /api/analyze, etc.            │   │
│  └──────────────────┬───────────────────────────────────┘   │
│                     │                                        │
│  ┌──────────────────▼───────────────────────────────────┐   │
│  │              サービス層                                │   │
│  │                                                       │   │
│  │  ┌──────────────┐  ┌──────────────┐                │   │
│  │  │ Google Meet  │  │ Google Chat  │                │   │
│  │  │   Service    │  │   Service    │                │   │
│  │  └──────────────┘  └──────────────┘                │   │
│  │                                                       │   │
│  │  ┌──────────────┐  ┌──────────────┐                │   │
│  │  │  LLM Service │  │  Scoring     │                │   │
│  │  │  (Vertex AI) │  │   Service    │                │   │
│  │  └──────────────┘  └──────────────┘                │   │
│  │                                                       │   │
│  │  ┌──────────────┐  ┌──────────────┐                │   │
│  │  │  Escalation  │  │  Output      │                │   │
│  │  │   Engine     │  │   Service    │                │   │
│  │  └──────────────┘  └──────────────┘                │   │
│  └───────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
```

### データフロー

#### 1. データ取り込みフロー

```
Google Meet/Chat
      │
      ▼
[議事録/チャット取得]
      │
      ▼
[パース処理]
      │
      ├─→ [発言者抽出]
      ├─→ [KPI検出]
      ├─→ [撤退議論検出]
      └─→ [リスク検出]
      │
      ▼
[構造化データ]
```

#### 2. 構造的問題検知フロー

```
[構造化データ]
      │
      ▼
[LLM Service]
      │
      ├─→ [Vertex AI / Gemini分析] (実APIモード)
      └─→ [ルールベース分析] (モックモード)
      │
      ▼
[パターン検出]
      │
      ├─→ B1_正当化フェーズ
      ├─→ ES1_報告遅延
      └─→ その他のパターン
      │
      ▼
[スコアリング & 説明生成]
      │
      ▼
[アラート生成 & 結果保存]
```

#### 3. Executive呼び出しフロー

```
[アラート生成]
      │
      ▼
[エスカレーション判断]
      │
      ├─→ [責任モデル参照]
      ├─→ [組織グラフ参照]
      └─→ [ロール選択]
      │
      ▼
[Executive呼び出し]
      │
      ▼
[承認待ち]
      │
      ├─→ [承認] ──→ [AI実行開始]
      └─→ [却下] ──→ [終了]
```

#### 4. AI自律実行フロー

```
[承認完了]
      │
      ▼
[タスク生成 (LLM)]
      │
      ├─→ [タスク1: 市場データ分析]
      ├─→ [タスク2: 社内データ統合]
      ├─→ [タスク3: 資料生成]
      ├─→ [タスク4: 通知送信]
      └─→ [タスク5: 会議設定]
      │
      ▼
[Google Workspace API]
      │
      ├─→ [リサーチ]
      ├─→ [分析]
      ├─→ [資料作成]
      └─→ [通知]
      │
      ▼
[Google Drive API]
      │
      ▼
[結果保存 & ダウンロードURL生成]
```

## 技術スタック

### フロントエンド

- **Next.js 16**: Reactベースのフレームワーク
- **TypeScript**: 型安全性の確保
- **Tailwind CSS**: スタイリング

### バックエンド

- **FastAPI**: PythonベースのAPIフレームワーク
- **Python 3.11+**: 主要なプログラミング言語
- **Uvicorn**: ASGIサーバー

### AI/ML

- **Vertex AI / Gemini**: 自然言語処理、テキスト解析
  - 構造的問題検知
  - タスク生成
  - 説明文生成

### データベース（将来実装）

- **Firestore**: 組織グラフ管理、構造的問題記録
- **BigQuery**: 時系列データ分析、メトリクス集計

### Google Cloud統合

- **Google Meet API**: 議事録取得
- **Google Chat API**: チャットメッセージ取得
- **Google Workspace API**: 資料生成、通知送信
- **Google Drive API**: ファイル保存、共有

## 実装のハイライト

### 1. 構造的問題検知ロジック

#### LLM統合

```python
class LLMService:
    """LLM統合サービス"""
    
    def analyze_structure(
        self,
        meeting_data: Dict[str, Any],
        chat_data: Optional[Dict[str, Any]] = None,
        materials_data: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """構造的問題検知"""
        # Vertex AI / Geminiを使用して分析
        # フォールバック: ルールベース分析
        ...
```

#### パターン検出

- **B1_正当化フェーズ**: KPI下方修正が2回以上、撤退議論なし、判断集中率70%以上
- **ES1_報告遅延**: リスク提起メッセージ存在、エスカレーション未完了

### 2. Executive呼び出しフロー

#### エスカレーション判断エンジン

```python
class EscalationEngine:
    """エスカレーション判断エンジン"""
    
    def create_escalation(
        self,
        analysis_id: str,
        analysis: Dict[str, Any]
    ) -> Dict[str, Any]:
        """エスカレーションを作成"""
        # 責任モデルに基づいて適切なロールを決定
        # エスカレーション理由を生成
        ...
```

### 3. AI自律実行

#### タスク生成

```python
def generate_tasks(
    self,
    analysis_result: Dict[str, Any],
    approval_data: Dict[str, Any],
    approved_interventions: Optional[List[str]] = None
) -> Dict[str, Any]:
    """タスクを生成"""
    # LLMを使用してタスクを生成
    # フォールバック: モックタスク
    ...
```

#### WebSocketによるリアルタイム進捗更新

```python
@app.websocket("/api/execution/{execution_id}/ws")
async def websocket_endpoint(websocket: WebSocket, execution_id: str):
    """実行進捗のリアルタイム更新"""
    # WebSocket接続を確立
    # 進捗をリアルタイムで送信
    ...
```

## デモ動画（3分）

デモ動画では、以下の流れを紹介します：

1. **Before（人だけの場合）** - Helm導入前の状況
2. **データ受領直後** - 議事録とチャットが取り込まれる
3. **Helm解析完了** - 構造的問題「B1_正当化フェーズ」が検知される（スコア75点）
4. **Executiveの判断** - 介入案を承認
5. **AI自律実行中** - タスクが順次実行される
6. **実行結果受領** - 生成された資料のダウンロードURL

[デモ動画のリンクをここに追加]

## 今後の展望

### 短期（1-2週間）

1. **実APIの動作確認** - モックモードから実APIモードへの移行確認
2. **実行進捗のリアルタイム表示** - WebSocket統合の改善
3. **UI/UX改善** - ローディング状態とエラーメッセージの改善

### 中期（1ヶ月）

1. **テストの拡充** - 品質保証の強化
2. **パフォーマンス最適化** - レスポンス時間の改善
3. **Firestore統合** - データの永続化

### 長期（2-3ヶ月）

1. **機能拡張** - Case2, Case3の実装
2. **組織グラフの実装** - エスカレーション先の自動決定
3. **運用体制の構築** - モニタリング、ログ管理、エラー通知

## まとめ

Helmは、**組織構造そのものを学習・改善するAI**として、以下の特徴を持ちます：

1. **AIが人を呼び出す**: 構造的問題を検知すると、自動的に適切なロールを呼び出す
2. **定量評価**: テキストから評価基準を自動抽出し、スコア（0-100点）に基づいて評価
3. **統合判断**: 複数情報源を統合的に評価し、組織全体を見た判断を提供

**Helm導入による定量的効果（フェルミ推定）:**
- 意思決定リードタイム: **70-85日 → 2日以内（97%削減、35倍改善）**
- Zombie Project検知率: **0% → 90%以上**
- 代替案検討率: **10%未満 → 50%以上（5倍以上改善）**
- 経営層レビュー負荷: **15h/週 → 3h/週（80%削減）**

Helmのビジョンは、**"Helm is where humans steer and AI rows."**です。人は舵を取る。AIは船でありパドルでありレーダーである。これは、既存の「人がAIを呼び出す」でも「完全自動化」でもない、**新しいヒト×AIの共生関係**です。

## 参考資料

- [GitHubリポジトリ](https://github.com/your-org/helm) - ソースコード
- [APIドキュメント](http://localhost:8000/docs) - API仕様
- [アーキテクチャドキュメント](./ARCHITECTURE.md) - システム設計の詳細
